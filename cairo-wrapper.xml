<?xml version="1.0"?>
<extension name="cairo" version="1.0.4">

 <summary>Cairo Wrapper Extension</summary>

 <description>
  A cairo API wrapper. For details about cairo see http://cairographics.org/.
 </description>

 <license>LGPL</license>

 <maintainers>
  <maintainer>
   <user>hholzgra</user>
   <name>Hartmut Holzgraefe</name>
   <email>hartmut@php.net</email>
   <role>lead</role>
  </maintainer>
 </maintainers>

 <channel>pecl.php.net</channel>

 <release>
  <version>0.2.2</version>
  <date>2006-11-15</date>
  <state>beta</state>
  <notes>
Stuff added since 0.2.1:
- reflection fix by disabling inclusion of
  cairo backwards compatibility macros
- package regenerated using latest CodeGen_PECL
  to resolve phpize problems on systems with
  older autoconf installations
- added comments to more constants
- *_create_* functions never return NULL, 
  error states need to be checked for using 
  *_status_* functions
  </notes>
 </release>

 <changelog>
  <release>
   <version>0.2.1</version>
   <date>2006-09-26</date>
   <state>beta</state>
   <notes>
    Stuff added since 0.2.0:
    - documentation
    - bug fixes
   </notes>
  </release>

  <release>
   <version>0.2.0</version>
   <date>2006-08-19</date>
   <state>beta</state>
   <notes>
    Almost feature complete now

    Stuff added since 1.0.3:
    - Postcript and SVG support
    - Font options and scaled fonts
    - Transformation matrixes

    Now working on documentation, 
    examples and test cases.
   </notes>
  </release>

  <release>
   <version>0.1.3</version>
   <date>2006-08-15</date>
   <state>alpha</state>
   <notes>
    - added PDF support 
    - improved phpinfo() output, now listing enabled features
   </notes>
  </release>

  <release>
   <version>0.1.2</version>
   <date>2006-08-14</date>
   <state>alpha</state>
   <notes>
    now using 
   </notes>
  </release>

  <release>
   <version>0.1.1</version>
   <date>2006-08-14</date>
   <state>alpha</state>
   <notes>
    added more functions
   </notes>
  </release>

  <release>
   <version>0.1.0</version>
   <date>2006-08-11</date>
   <state>alpha</state>
   <notes>
    first tests
   </notes>
  </release>

 </changelog>

 <deps>
  <with name="cairo" mode="pkg-config" version="1.2.2">
   <header name="cairo.h"/>
   This extension requires the Cairo Vector Graphics Library version 1.2.2 
   or above and a working pkg-config installation.
  </with>
  <define name="_CAIROINT_H_" value="1" comment="do not include BC definitions" />
 </deps>

 <code role="header">
<![CDATA[

#if CAIRO_HAS_PDF_SURFACE
#include <cairo-pdf.h>
#endif

#if CAIRO_HAS_PS_SURFACE
#include <cairo-ps.h>
#endif

#if CAIRO_HAS_SVG_SURFACE
#include <cairo-svg.h>
#endif

]]>
 </code>

 <function name="MINFO" role="internal">
  <code>
<![CDATA[
	php_info_print_table_start();
	php_info_print_table_header(2, "Cairo Wrapper", "enabled");
    php_info_print_table_row(2, "Cairo Version", CAIRO_VERSION_STRING);

#if CAIRO_HAS_PNG_FUNCTIONS
    php_info_print_table_row(2, "PNG backend", "yes");
#else 
    php_info_print_table_row(2, "PNG backend", "no");
#endif

#if CAIRO_HAS_SVG_SURFACE
    php_info_print_table_row(2, "SVG backend", "yes");
#else 
    php_info_print_table_row(2, "SVG backend", "no");
#endif

#if CAIRO_HAS_QUARTZ_SURFACE
    php_info_print_table_row(2, "Quartz backend", "yes");
#else 
    php_info_print_table_row(2, "Quartz backend", "no");
#endif

#if CAIRO_HAS_XCB_SURFACE
    php_info_print_table_row(2, "XCB backend", "yes");
#else 
    php_info_print_table_row(2, "XCB backend", "no");
#endif

#if CAIRO_HAS_WIN32_SURFACE
    php_info_print_table_row(2, "Win32 backend", "yes");
#else 
    php_info_print_table_row(2, "Win32 backend", "no");
#endif

#if CAIRO_HAS_PDF_SURFACE
    php_info_print_table_row(2, "PDF backend", "yes");
#else 
    php_info_print_table_row(2, "PDF backend", "no");
#endif

#if CAIRO_HAS_PS_SURFACE
    php_info_print_table_row(2, "PS backend", "yes");
#else 
    php_info_print_table_row(2, "PS backend", "no");
#endif

#if CAIRO_HAS_XLIB_SURFACE
    php_info_print_table_row(2, "Xlib backend", "yes");
#else 
    php_info_print_table_row(2, "Xlib backend", "no");
#endif

#if CAIRO_HAS_XLIB_RENDER_SURFACE
    php_info_print_table_row(2, "Xlib render backend", "yes");
#else 
    php_info_print_table_row(2, "Xlib render backend", "no");
#endif

#if CAIRO_HAS_BEOS_SURFACE
    php_info_print_table_row(2, "BeOS backend", "yes");
#else 
    php_info_print_table_row(2, "BeOS backend", "no");
#endif

#if CAIRO_HAS_GLITZ_SURFACE
    php_info_print_table_row(2, "Glitz backend", "yes");
#else 
    php_info_print_table_row(2, "Glitz backend", "no");
#endif

#if CAIRO_HAS_DIRECTFB_SURFACE
    php_info_print_table_row(2, "FrameBuffer backend", "yes");
#else 
    php_info_print_table_row(2, "FrameBuffer backend", "no");
#endif

#if CAIRO_HAS_FT_FONT
    php_info_print_table_row(2, "freetype font support", "yes");
#else 
    php_info_print_table_row(2, "freetype font support", "no");
#endif

#if CAIRO_HAS_WIN32_FONT
    php_info_print_table_row(2, "Win32 font support", "yes");
#else 
    php_info_print_table_row(2, "Win32 font support", "no");
#endif

#if CAIRO_HAS_ATSUI_FONT
    php_info_print_table_row(2, "ATSUI font support", "yes");
#else 
    php_info_print_table_row(2, "ATSUI font support", "no");
#endif

	php_info_print_table_end();

]]>
  </code>
 </function>

  <constants group="Cairo Status">
    <constant name="CAIRO_STATUS_SUCCESS">
     OK status, no errors.
    </constant>
    <constant name="CAIRO_STATUS_NO_MEMORY">
     Out of memory
    </constant>
    <constant name="CAIRO_STATUS_INVALID_RESTORE">
     cairo_restore without matching cairo_save
    </constant>
    <constant name="CAIRO_STATUS_INVALID_POP_GROUP">
     no saved group to pop
    </constant>
    <constant name="CAIRO_STATUS_NO_CURRENT_POINT">
     no current point defined
    </constant>
    <constant name="CAIRO_STATUS_INVALID_MATRIX">
     invalid matrix (not invertible)
    </constant>
    <constant name="CAIRO_STATUS_INVALID_STATUS">
     invalid value for an input cairo_status_t
    </constant>
    <constant name="CAIRO_STATUS_NULL_POINTER">
     NULL pointer
    </constant>
    <constant name="CAIRO_STATUS_INVALID_STRING">
     input string not valid UTF-8
    </constant>
    <constant name="CAIRO_STATUS_INVALID_PATH_DATA">
     input path data not valid
    </constant>
    <constant name="CAIRO_STATUS_READ_ERROR">
     error while reading from input stream
    </constant>
    <constant name="CAIRO_STATUS_WRITE_ERROR">
     error while writing to output stream
    </constant>
    <constant name="CAIRO_STATUS_SURFACE_FINISHED">
     target surface has been finished
    </constant>
    <constant name="CAIRO_STATUS_SURFACE_TYPE_MISMATCH">
     the surface type is not appropriate for the operation
    </constant>
    <constant name="CAIRO_STATUS_PATTERN_TYPE_MISMATCH">
     the pattern type is not appropriate for the operation
    </constant>
    <constant name="CAIRO_STATUS_INVALID_CONTENT">
     invalid value for an input cairo_content_t
    </constant>
    <constant name="CAIRO_STATUS_INVALID_FORMAT">
     invalid value for an input cairo_format_t
    </constant>
    <constant name="CAIRO_STATUS_INVALID_VISUAL">
     invalid value for an input Visual*
    </constant>
    <constant name="CAIRO_STATUS_FILE_NOT_FOUND">
     file not found
    </constant>
    <constant name="CAIRO_STATUS_INVALID_DASH">
     invalid value for a dash setting
    </constant>
    <constant name="CAIRO_STATUS_INVALID_DSC_COMMENT">
     invalid value for a DSC comment (Since 1.2)
    </constant>
  </constants>

  <constants group="Content Type">
    <constant name="CAIRO_CONTENT_COLOR">
     The surface will hold color content only.
    </constant>
    <constant name="CAIRO_CONTENT_ALPHA">
     The surface will hold alpha content only.
    </constant>
    <constant name="CAIRO_CONTENT_COLOR_ALPHA">
     The surface will hold color and alpha content. 
    </constant>
  </constants>

  <constants group="Operation Type">
    <constant name="CAIRO_OPERATOR_CLEAR">
    </constant>
    <constant name="CAIRO_OPERATOR_SOURCE">
    </constant>
    <constant name="CAIRO_OPERATOR_OVER">
    </constant>
    <constant name="CAIRO_OPERATOR_IN">
    </constant>
    <constant name="CAIRO_OPERATOR_OUT">
    </constant>
    <constant name="CAIRO_OPERATOR_ATOP">
    </constant>
    <constant name="CAIRO_OPERATOR_DEST">
    </constant>
    <constant name="CAIRO_OPERATOR_DEST_OVER">
    </constant>
    <constant name="CAIRO_OPERATOR_DEST_IN">
    </constant>
    <constant name="CAIRO_OPERATOR_DEST_OUT">
    </constant>
    <constant name="CAIRO_OPERATOR_DEST_ATOP">
    </constant>
    <constant name="CAIRO_OPERATOR_XOR">
    </constant>
    <constant name="CAIRO_OPERATOR_ADD">
    </constant>
    <constant name="CAIRO_OPERATOR_SATURATE">
    </constant>
  </constants>

  <constants group="Antialiasing Type">
    <constant name="CAIRO_ANTIALIAS_DEFAULT">
     Use the default antialiasing for the subsystem and target device
    </constant>
    <constant name="CAIRO_ANTIALIAS_NONE">
     Use a bilevel alpha mask
    </constant>
    <constant name="CAIRO_ANTIALIAS_GRAY">
    </constant>
     Perform single-color antialiasing (using shades of gray for black text on a white background, for example).
    <constant name="CAIRO_ANTIALIAS_SUBPIXEL">
     Perform antialiasing by taking advantage of the order of subpixel elements on devices such as LCD panels    
    </constant>
  </constants>

  <constants group="Fill Rule">
    <constant name="CAIRO_FILL_RULE_WINDING">
    </constant>
    <constant name="CAIRO_FILL_RULE_EVEN_ODD">
    </constant>
  </constants>

  <constants group="Line Cap">
    <constant name="CAIRO_LINE_CAP_BUTT">
     start(stop) the line exactly at the start(end) point
    </constant>
    <constant name="CAIRO_LINE_CAP_ROUND">
     use a round ending, the center of the circle is the end point
    </constant>
    <constant name="CAIRO_LINE_CAP_SQUARE">
     use squared ending, the center of the square is the end point
    </constant>
  </constants>

  <constants group="Line Join">
    <constant name="CAIRO_LINE_JOIN_MITER">
      Join the path segment by extending the outer border until they intersect.  
    </constant>
    <constant name="CAIRO_LINE_JOIN_ROUND">
      Join the path segment with a pie-like patch, such that the outer line of the meeting point is round.  
    </constant>
    <constant name="CAIRO_LINE_JOIN_BEVEL">
      Join the path segment by connecting the outer ends of the abutting segments with a straight line.  
    </constant>
  </constants>

  <constants group="Font Slant">
    <constant name="CAIRO_FONT_SLANT_NORMAL">
     Normal upright font slant.
    </constant>
    <constant name="CAIRO_FONT_SLANT_ITALIC">
     Italic font slant.
    </constant>
    <constant name="CAIRO_FONT_SLANT_OBLIQUE">
     Oblique font slant.
    </constant>
  </constants>

  <constants group="Font Weight">
    <constant name="CAIRO_FONT_WEIGHT_NORMAL">
     Normal font weight.
    </constant>
    <constant name="CAIRO_FONT_WEIGHT_BOLD">
     Bold font.
    </constant>
  </constants>

  <constants group="Subpixel Order">
    <constant name="CAIRO_SUBPIXEL_ORDER_DEFAULT">
     Use the default subpixel order for for the target device
    </constant>
    <constant name="CAIRO_SUBPIXEL_ORDER_RGB">
     Subpixel elements are arranged horizontally with red at the left
    </constant>
    <constant name="CAIRO_SUBPIXEL_ORDER_BGR">
     Subpixel elements are arranged horizontally with blue at the left
    </constant>
    <constant name="CAIRO_SUBPIXEL_ORDER_VRGB">
     Subpixel elements are arranged vertically with red at the top
    </constant>
    <constant name="CAIRO_SUBPIXEL_ORDER_VBGR">
     Subpixel elements are arranged vertically with blue at the top 
    </constant>
  </constants>

  <constants group="Hint Style">
    <constant name="CAIRO_HINT_STYLE_DEFAULT">
     Use the default hint style for for font backend and target device
    </constant>
    <constant name="CAIRO_HINT_STYLE_NONE">
     Do not hint outlines
    </constant>
    <constant name="CAIRO_HINT_STYLE_SLIGHT">
     Hint outlines slightly to improve contrast while retaining good fidelity to the original shapes.
    </constant>
    <constant name="CAIRO_HINT_STYLE_MEDIUM">
     Hint outlines with medium strength giving a compromise between fidelity to the original shapes and contrast
    </constant>
    <constant name="CAIRO_HINT_STYLE_FULL">
     Hint outlines to maximize contrast
    </constant>
  </constants>

  <constants group="Hint Metrics">
    <constant name="CAIRO_HINT_METRICS_DEFAULT">
     Hint metrics in the default manner for the font backend and target device
    </constant>
    <constant name="CAIRO_HINT_METRICS_OFF"> 
     Do not hint font metrics
    </constant>
    <constant name="CAIRO_HINT_METRICS_ON">  
     Hint font metrics
    </constant>
  </constants>

  <constants group="Font Type">
    <constant name="CAIRO_FONT_TYPE_TOY">
      The font was created using cairo's toy font api
    </constant>
    <constant name="CAIRO_FONT_TYPE_FT">
     TrueType font
    </constant>
    <constant name="CAIRO_FONT_TYPE_WIN32">
     Win32 font
    </constant>
    <constant name="CAIRO_FONT_TYPE_ATSUI">
     ATSUI font
    </constant>
  </constants>

  <constants group="Path Operation">
    <constant name="CAIRO_PATH_MOVE_TO">
     Move drawing position to a new point without drawing.
    </constant>
    <constant name="CAIRO_PATH_LINE_TO">
     Draw a straight line from the current to the new drawing point.
    </constant>
    <constant name="CAIRO_PATH_CURVE_TO">
     Draw a cubic spline from the current to the new drawing point.
    </constant>
    <constant name="CAIRO_PATH_CLOSE_PATH">
     Close the drawing path by drawing a straight line from the current
     drawing point to the path starting point.
    </constant>
  </constants>

  <constants group="Surface Type">
    <constant name="CAIRO_SURFACE_TYPE_IMAGE">
     Bitmap image (PNG)
    </constant>
    <constant name="CAIRO_SURFACE_TYPE_PDF">
     PDF document
    </constant>
    <constant name="CAIRO_SURFACE_TYPE_PS">
     PostScript Document
    </constant>
    <constant name="CAIRO_SURFACE_TYPE_XLIB">
     Xlib suface
    </constant>
    <constant name="CAIRO_SURFACE_TYPE_XCB">
     XCB surface
    </constant>
    <constant name="CAIRO_SURFACE_TYPE_GLITZ">
     Glitz surface
    </constant>
    <constant name="CAIRO_SURFACE_TYPE_QUARTZ">
     Mac OS/X Quartz surface
    </constant>
    <constant name="CAIRO_SURFACE_TYPE_WIN32">
     Mircosoft Win32 surface
    </constant>
    <constant name="CAIRO_SURFACE_TYPE_BEOS">
     BeOS surface
    </constant>
    <constant name="CAIRO_SURFACE_TYPE_DIRECTFB">
     Direct framebuffer outout
    </constant>
    <constant name="CAIRO_SURFACE_TYPE_SVG">
     Scalable Vector Graphics surface
    </constant>
  </constants>

  <constants group="Bitmap Format">
    <constant name="CAIRO_FORMAT_ARGB32">
     Each pixel is a 32-bit quantity, with alpha in the upper 8 bits, 
     then red, then green, then blue. The 32-bit quantities are stored 
     native-endian. Pre-multiplied alpha is used. (That is, 50% 
     transparent red is 0x80800000, not 0x80ff0000.)
     </constant>
    <constant name="CAIRO_FORMAT_RGB24">
     Each pixel is a 32-bit quantity, with the upper 8 bits unused. 
     Red, Green, and Blue are stored in the remaining 24 bits in that order.
    </constant>
    <constant name="CAIRO_FORMAT_A8">
     Each pixel is a 8-bit quantity holding an alpha value.
    </constant>
    <constant name="CAIRO_FORMAT_A1">
     Each pixel is a 1-bit quantity holding an alpha value. Pixels are packed 
     together into 32-bit quantities. The ordering of the bits matches the 
     endianess of the platform. On a big-endian machine, the first pixel is 
     in the uppermost bit, on a little-endian machine the first pixel is in 
     the least-significant bit.
    </constant>
    <constant name="CAIRO_FORMAT_RGB16_565">
     Each pixel is a 16-bit quantity, with red in the upper 5 bits, 
     then green in the next 6, then blue in the lowest 5 bits.
    </constant>
  </constants>

  <constants group="Pattern Type">
    <constant name="CAIRO_PATTERN_TYPE_SOLID">
     The pattern is a solid (uniform) color. It may be opaque or translucent.
    </constant>
    <constant name="CAIRO_PATTERN_TYPE_SURFACE">
     The pattern is a based on a surface (an image).
    </constant>
    <constant name="CAIRO_PATTERN_TYPE_LINEAR">
     The pattern is a linear gradient.
    </constant>
    <constant name="CAIRO_PATTERN_TYPE_RADIAL">
     The pattern is a radial gradient.
    </constant>
  </constants>

  <constants group="Extend Type">
    <constant name="CAIRO_EXTEND_NONE">
     pixels outside of the source pattern are fully transparent
    </constant>
    <constant name="CAIRO_EXTEND_REPEAT">
     the pattern is tiled by repeating
    </constant>
    <constant name="CAIRO_EXTEND_REFLECT">
     the pattern is tiled by reflecting at the edges (not implemented for surface patterns currently)
    </constant>
    <constant name="CAIRO_EXTEND_PAD">
     pixels outside of the pattern copy the closest pixel from the source (Since 1.2; not implemented for surface patterns currently)
    </constant>
  </constants>

  <constants group="Filter Type">
    <constant name="CAIRO_FILTER_FAST">
     'Fast' filter.
    </constant>
    <constant name="CAIRO_FILTER_GOOD">
     'Good' filter.
    </constant>
    <constant name="CAIRO_FILTER_BEST">
     'Best' filter.
    </constant>
    <constant name="CAIRO_FILTER_NEAREST">
     'Nearest' filter.
    </constant>
    <constant name="CAIRO_FILTER_BILINEAR">
     Bi-linear filter.
    </constant>
    <constant name="CAIRO_FILTER_GAUSSIAN">
     Gaussian filter.
    </constant>
  </constants>

  <constants group="SVG Version">
    <constant name="CAIRO_SVG_VERSION_1_1">
     SVG Version 1.1
    </constant>
    <constant name="CAIRO_SVG_VERSION_1_2">
     SVG Version 1.2
    </constant>
  </constants>

 <resource name="cairo_surface" payload="cairo_surface_t" alloc="no">
  <description>
   A cairo surface describes the actual output device or file format drawing operations are performed on.
  </description>
  <destruct>
   cairo_surface_destroy(resource);   
  </destruct>
 </resource>

 <function name="cairo_image_surface_create">
  <proto>resource cairo_surface cairo_image_surface_create(int format, int x, int y)</proto>
  <summary>Create new bitmap surface resource</summary>
  <description>
   ...
  </description>
  <code>
    return_res = cairo_image_surface_create(format, x, y);
  </code>
 </function>

 <function name="cairo_surface_destroy">
  <proto>void cairo_surface_destroy(resource cairo_surface surface)</proto>
  <summary>Destroy surface resource</summary>
  <description>
   ...
  </description>
  <code>
    FREE_RESOURCE(surface_res);
  </code>
 </function>

 <resource name="cairo_context" payload="cairo_t" alloc="no">
  <description>
   A cairo drawing context. This is where drawing operations are collected before they 
   are finally applied to a cairo surface.
  </description>
  <destruct>
   cairo_destroy(resource);   
  </destruct>
 </resource>

 <function name="cairo_create">
  <proto>resource cairo_context cairo_create(resource cairo_surface surface)</proto>
  <summary>Create new drawing context resource</summary>
  <description>
   <para>
    Creates a new <type>cairo_context</type> resource with all graphics state 
    parameters set to default values and with <parameter>surface</parameter> 
    as a target surface. The target surface should be constructed with a 
    backend-specific function such as <function>cairo_image_surface_create</function> 
    (or any other <literal>cairo_&lt;backend&gt;_surface_create</literal> variant).
   </para>
   <para>
    This function references <parameter>surface</parameter>, so you can immediately
    call <function>cairo_surface_destroy</function> on it if you don't need to
    maintain a separate reference to it.
   </para>
   
   <variablelist role="params">
<varlistentry><term><parameter>target</parameter>:</term>
<listitem><simpara> target surface for the context
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>:</term><listitem><simpara> a newly allocated <type>cairo_context</type> with a reference
 count of 1. The initial reference count should be released
 with <function>cairo_destroy</function> when you are done using the <type>cairo_context</type>.
 This function never returns NULL. If memory cannot be
 allocated, a special <type>cairo_resource</type> resource will be returned on
 which <function>cairo_status</function> returns <literal>CAIRO_STATUS_NO_MEMORY</literal>.
 You can use this object normally, but no drawing will be done.
</simpara></listitem></varlistentry>
</variablelist>
  </description>
  <code>
    return_res = cairo_create(surface);
  </code>
 </function>

 <function name="cairo_destroy">
  <proto>void cairo_destroy(resource cairo_context cr)</proto>
  <summary>Destroy drawing context resource</summary>
  <description>
   ...
  </description>
  <code>
    FREE_RESOURCE(cr_res);
  </code>
 </function>

 <resource name="cairo_pattern" payload="cairo_pattern_t" alloc="no">
  <description>
   A cairo fill pattern used for fill and paint operations.
  </description>
  <destruct>
   cairo_pattern_destroy(resource);   
  </destruct>
 </resource>

 <function name="cairo_pattern_create_linear">
  <proto>resource cairo_pattern cairo_pattern_create_linear(float x0, float y0, float x1, float y1)</proto>
  <summary>Create a linear fill pattern</summary>
  <description>
   ...
  </description>
  <code>
    return_res = cairo_pattern_create_linear(x0, y0, x1, y1);
  </code>
 </function>

 <function name="cairo_pattern_create_radial">
  <proto>resource cairo_pattern cairo_pattern_create_radial(float cx0, float cy0, float radius0, float cx1, float cy1, float radius1)</proto>
  <summary>Create a radial fill pattern</summary>
  <description>
   ...
  </description>
  <code>
    return_res = cairo_pattern_create_radial(cx0,  cy0,  radius0,  cx1,  cy1,  radius1);
  </code>
 </function>

 <function name="cairo_pattern_create_for_surface">
  <proto>resource cairo_pattern cairo_pattern_create_for_surface(resource cairo_surface surface)</proto>
  <summary>Create a fill pattern from an existing surface resource</summary>
  <description>
   ...
  </description>
  <code>
    return_res = cairo_pattern_create_for_surface(surface);
  </code>
 </function>

 <function name="cairo_pattern_create_rgb">
  <proto>resource cairo_pattern cairo_pattern_create_rgb(float red, float green, float blue)</proto>
  <summary>Create a solid color fill pattern</summary>
  <description>
   ...
  </description>
  <code>
    return_res = cairo_pattern_create_rgb(red, green, blue);
  </code>
 </function>

 <function name="cairo_pattern_create_rgba">
  <proto>resource cairo_pattern cairo_pattern_create_rgba(float red, float green, float blue, float alpha)</proto>
  <summary>Create a transparent colored fill pattern</summary>
  <description>
   ...
  </description>
  <code>
    return_res = cairo_pattern_create_rgba(red, green, blue, alpha);
  </code>
 </function>

 <function name="cairo_pattern_destroy">
  <proto>void cairo_pattern_destroy(resource cairo_pattern cr)</proto>
  <summary>Destroy a fill pattern resource</summary>
  <description>
   ...
  </description>
  <code>
    FREE_RESOURCE(cr_res);
  </code>
 </function>

 <resource name="cairo_path" payload="cairo_path_t" alloc="no">
  <description>
   A collection of path operations describing a path used for strokes,
   filling, clipping etc.
  </description>
  <destruct>
   cairo_path_destroy(resource);   
  </destruct>
 </resource>

 <function name="cairo_path_destroy">
  <proto>void cairo_path_destroy(resource cairo_path cr)</proto>
  <summary>Destroy a drawing path resource</summary>
  <description>
   ...
  </description>
  <code>
    FREE_RESOURCE(cr_res);
  </code>
 </function>

 <function name="cairo_select_font_face">
  <proto>void cairo_select_font_face(resource cairo_context cr, string fontname, int slant, int weight)</proto>
  <summary>Set current font for a drawing context</summary>
  <description>
   ...
  </description>
  <code>
    cairo_select_font_face(cr, fontname, slant, weight);
  </code>
 </function>

 <function name="cairo_set_font_size">
  <proto>void cairo_set_font_size(resource cairo_context cr, float size)</proto>
  <summary>Set current font size for a drawing context</summary>
  <description>
   ...
  </description>
  <code>
    cairo_set_font_size(cr, size);
  </code>
 </function>

 <function name="cairo_set_source_rgb">
  <proto>void cairo_set_source_rgb(resource cairo_context cr, float red, float green, float blue)</proto>
  <summary>Set opaque drawing color for a drawing context</summary>
  <description>
   ...
  </description>
  <code>
    cairo_set_source_rgb(cr, red, green, blue);
  </code>
 </function>

 <function name="cairo_set_source_rgba">
  <proto>void cairo_set_source_rgba(resource cairo_context cr, float red, float green, float blue, float alpha)</proto>
  <summary>Set transparent drawing color for a drawing context</summary>
  <description>
   ...
  </description>
  <code>
    cairo_set_source_rgba(cr, red, green, blue, alpha);
  </code>
 </function>

 <function name="cairo_move_to">
  <proto>void cairo_move_to(resource cairo_context cr, float x, float y)</proto>
  <summary>Set current drawing position to a new starting point</summary>
  <description>
   ...
  </description>
  <code>
    cairo_move_to(cr, x, y);
  </code>
 </function>

 <function name="cairo_rel_move_to">
  <proto>void cairo_rel_move_to(resource cairo_context cr, float dx, float dy)</proto>
  <summary>Move current drawing position relative to current position</summary>
  <description>
   ...
  </description>
  <code>
    cairo_rel_move_to(cr, dx, dy);
  </code>
 </function>

 <function name="cairo_show_text">
  <proto>void cairo_show_text(resource cairo_context cr, string text)</proto>
  <summary>Show text at current position using current font</summary>
  <description>
   ...
  </description>
  <code>
    cairo_show_text(cr, text);
  </code>
 </function>

 <code position="top">
  static cairo_status_t _cairo_write(void *closure, const unsigned char *data, unsigned int length) {
    PHPWRITE((const char *)data, length);
    return CAIRO_STATUS_SUCCESS;
  }

  static cairo_status_t _cairo_write_stream(void *stream, const unsigned char *data, unsigned int length) {
    if (length != php_stream_write((php_stream *)stream, (const char *)data, length)) {
      return CAIRO_STATUS_WRITE_ERROR;
    }

    return CAIRO_STATUS_SUCCESS;
  }

  static cairo_status_t _cairo_read_stream(void *stream, unsigned char *data, unsigned int length) {
    if (length != php_stream_read((php_stream *)stream, (char *)data, length)) {
      return CAIRO_STATUS_READ_ERROR;
    }

    return CAIRO_STATUS_SUCCESS;
  }
 </code>

 <function name="cairo_surface_show_png" if="CAIRO_HAS_PNG_FUNCTIONS">
  <proto>void cairo_surface_show_png(resource cairo_surface surface)</proto>
  <summary>Create immediate PNG image output</summary>
  <description>
   ...
  </description>
  <code>
    cairo_surface_write_to_png_stream(surface, _cairo_write, NULL);
  </code>
 </function>

 <function name="cairo_surface_write_to_png" if="CAIRO_HAS_PNG_FUNCTIONS">
  <proto>void cairo_surface_write_to_png(resource cairo_surface surface, string path)</proto>
  <summary>Save surface contents to a PNG file</summary>
  <description>
   ...
  </description>
  <code>
    php_stream *stream;
    stream = php_stream_open_wrapper((char *)path, "wb", ENFORCE_SAFE_MODE | REPORT_ERRORS, NULL);

	if (stream) {
      cairo_surface_write_to_png_stream(surface, _cairo_write_stream, stream);
      php_stream_close(stream);
    }
  </code>
 </function>

 <function name="cairo_image_surface_create_from_png" if="CAIRO_HAS_PNG_FUNCTIONS">
  <proto>resource cairo_surface cairo_image_surface_create_from_png(string path)</proto>
  <summary>Create new drawing surface from a PNG file</summary>
  <description>
   ...
  </description>
  <code>
    php_stream *stream;
    stream = php_stream_open_wrapper((char *)path, "rb", ENFORCE_SAFE_MODE | REPORT_ERRORS, NULL);

    if (!stream) {
      RETURN_FALSE;
    }
 
    return_res = cairo_image_surface_create_from_png_stream(_cairo_read_stream, stream);
    php_stream_close(stream);
  </code>
 </function>

 <code position="top">
  void _cairo_close_stream(void *data)
  {
    php_stream_close((php_stream *)data);
  }
 </code>

 <function name="cairo_pdf_surface_create" if="CAIRO_HAS_PDF_SURFACE">
  <proto>resource cairo_surface cairo_pdf_surface_create(string path, float width_in_points, float height_in_points)</proto>
  <summary>Create a new surface for PDF output</summary>
  <description>
   ...
  </description>
  <code>
    cairo_status_t status;
    php_stream *stream = php_stream_open_wrapper((char *)path, "wb", ENFORCE_SAFE_MODE | REPORT_ERRORS, NULL);

    if (!stream) {
      RETURN_FALSE;
    }
 
    return_res = cairo_pdf_surface_create_for_stream(_cairo_write_stream, stream, width_in_points, height_in_points);
    status = cairo_surface_set_user_data(return_res, (cairo_user_data_key_t *)cairo_pdf_surface_create, stream, _cairo_close_stream);
    <!-- TODO error checking -->
  </code>
 </function>

 <function name="cairo_pdf_surface_set_size" if="CAIRO_HAS_PDF_SURFACE">
  <proto>void cairo_pdf_surface_set_size(resource cairo_surface surface, float width_in_points, float height_in_points)</proto>
  <summary>Set size for current PDF page</summary>
  <description>
   ...
  </description>
  <code>
    cairo_pdf_surface_set_size(surface, width_in_points, height_in_points);
  </code>
 </function>

 <function name="cairo_ps_surface_create" if="CAIRO_HAS_PS_SURFACE">
  <proto>resource cairo_surface cairo_ps_surface_create(string path, float width_in_points, float height_in_points)</proto>
  <summary>Create a new surface for Postscript output</summary>
  <description>
   ...
  </description>
  <code>
    cairo_status_t status;
    php_stream *stream = php_stream_open_wrapper((char *)path, "wb", ENFORCE_SAFE_MODE | REPORT_ERRORS, NULL);

    if (!stream) {
      RETURN_FALSE;
    }
 
    return_res = cairo_ps_surface_create_for_stream(_cairo_write_stream, stream, width_in_points, height_in_points);
    status = cairo_surface_set_user_data(return_res, (cairo_user_data_key_t *)cairo_ps_surface_create, stream, _cairo_close_stream);
  </code>
 </function>

 <function name="cairo_ps_surface_set_size" if="CAIRO_HAS_PS_SURFACE">
  <proto>void cairo_ps_surface_set_size(resource cairo_surface surface, float width_in_points, float height_in_points)</proto>
  <summary>Set size for current Postscript page</summary>
  <description>
   ...
  </description>
  <code>
    cairo_ps_surface_set_size(surface, width_in_points, height_in_points);
  </code>
 </function>

 <function name="cairo_ps_surface_dsc_begin_setup" if="CAIRO_HAS_PS_SURFACE">
  <proto>void cairo_ps_surface_dsc_begin_setup(resource cairo_surface surface)</proto>
  <summary>Direct following comments to the general setup section</summary>
  <description>
   ...
  </description>
  <code>
    cairo_ps_surface_dsc_begin_setup(surface);
  </code>
 </function>

 <function name="cairo_ps_surface_dsc_begin_page_setup" if="CAIRO_HAS_PS_SURFACE">
  <proto>void cairo_ps_surface_dsc_begin_page_setup(resource cairo_surface surface)</proto>
  <summary>Direct following comments to the page setup section</summary>
  <description>
   ...
  </description>
  <code>
    cairo_ps_surface_dsc_begin_page_setup(surface);
  </code>
 </function>

 <function name="cairo_ps_surface_dsc_comment" if="CAIRO_HAS_PS_SURFACE">
  <proto>void cairo_ps_surface_dsc_comment(resource cairo_surface surface, string comment)</proto>
  <summary>Emmit a comment into the preselected setup section</summary>
  <description>
   ...
  </description>
  <code>
    cairo_ps_surface_dsc_comment(surface, comment);
  </code>
 </function>

 <function name="cairo_stroke">
  <proto>void cairo_stroke(resource cairo_context cr)</proto>
  <summary>Draw current path to surface</summary>
  <description>
   ...
  </description>
  <code>
    cairo_stroke(cr);
  </code>
 </function>

 <function name="cairo_stroke_preserve">
  <proto>void cairo_stroke_preserve(resource cairo_context cr)</proto>
  <summary>Draw current path to surface and keep it for further operations</summary>
  <description>
   ...
  </description>
  <code>
    cairo_stroke_preserve(cr);
  </code>
 </function>

 <function name="cairo_arc">
  <proto>void cairo_arc(resource cairo_context cr, float xc, float yc, float radius, float angle1, float angle2);</proto>
  <summary>Draw an arc clockwise</summary>
  <description>
   ...
  </description>
  <code>
    cairo_arc(cr, xc, yc, radius, angle1, angle2);
  </code>
 </function>

 <function name="cairo_arc_negative">
  <proto>void cairo_arc_negative(resource cairo_context cr, float xc, float yc, float radius, float angle1, float angle2);</proto>
  <summary>Draw an arc counter-clockwise</summary>
  <description>
   ...
  </description>
  <code>
    cairo_arc_negative(cr, xc, yc, radius, angle1, angle2);
  </code>
 </function>

 <function name="cairo_fill">
  <proto>void cairo_fill(resource cairo_context cr)</proto>
  <summary>Fill the current path</summary>
  <description>
   ...
  </description>
  <code>
    cairo_fill(cr);
  </code>
 </function>

 <function name="cairo_fill_preserve">
  <proto>void cairo_fill_preserve(resource cairo_context cr)</proto>
  <summary>Fill the current path and keep it for further operations</summary>
  <description>
   ...
  </description>
  <code>
    cairo_fill_preserve(cr);
  </code>
 </function>

 <function name="cairo_set_line_width">
  <proto>void cairo_set_line_width(resource cairo_context cr, float width)</proto>
  <summary>Set line width for the next stroke operation</summary>
  <description>
   ...
  </description>
  <code>
    cairo_set_line_width(cr, width);
  </code>
 </function>

 <function name="cairo_get_line_width">
  <proto>float cairo_get_line_width(resource cairo_context cr, float width)</proto>
  <summary>Get current line width</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_DOUBLE(cairo_get_line_width(cr));
  </code>
 </function>

 <function name="cairo_line_to">
  <proto>void cairo_line_to(resource cairo_context cr, float xc, float yc)</proto>
  <summary>Draw a line starting at the current drawing position</summary>
  <description>
   ...
  </description>
  <code>
    cairo_line_to(cr, xc, yc);
  </code>
 </function>

 <function name="cairo_rel_line_to">
  <proto>void cairo_rel_line_to(resource cairo_context cr, float dx, float dy)</proto>
  <summary>Draw a line from the current drawing position using relative offsets</summary>
  <description>
   ...
  </description>
  <code>
    cairo_line_to(cr, dx, dy);
  </code>
 </function>

 <function name="cairo_pattern_add_color_stop_rgb">
  <proto>void cairo_pattern_add_color_stop_rgb(resource cairo_pattern pattern, float offset, float red, float green, float blue)</proto>
  <summary>Set opaque target color for a given fill pattern gradient control vector offset</summary>
  <description>
   ...
  </description>
  <code>
    cairo_pattern_add_color_stop_rgb(pattern, offset, red, green, blue);
  </code>
 </function>

 <function name="cairo_pattern_add_color_stop_rgba">
  <proto>void cairo_pattern_add_color_stop_rgba(resource cairo_pattern pattern, float offset, float red, float green, float blue, float alpha)</proto>
  <summary>Set translucent target color for a given fill pattern gradient control vector offset</summary>
  <description>
   ...
  </description>
  <code>
    cairo_pattern_add_color_stop_rgba(pattern, offset, red, green, blue, alpha);
  </code>
 </function>

 <function name="cairo_rectangle">
  <proto>void cairo_rectangle(resource cairo_context cr, float x, float y, float width, float height)</proto>
  <summary>Draw a rectangle</summary>
  <description>
   ...
  </description>
  <code>
    cairo_rectangle(cr, x, y, width, height);
  </code>
 </function>

 <function name="cairo_set_source">
  <proto>void cairo_set_source (resource cairo_context cr, resource cairo_pattern pattern)</proto>
  <summary>Set source fill pattern for drawing context</summary>
  <description>
   ...
  </description>
  <code>
    cairo_set_source(cr, pattern);
  </code>
 </function>

 <function name="cairo_scale">
  <proto>void cairo_scale (resource cairo_context cr, int width, int height)</proto>
  <summary>Change scaling of current drawing context</summary>
  <description>
   ...
  </description>
  <code>
    cairo_scale(cr, width, height);
  </code>
 </function>

 <function name="cairo_version">
  <proto>int cairo_version(void)</proto>
  <summary>Return cairo library version</summary>
  <description>
   <para>
    Returns the Cairo library version as integer of the form 10000*MAJOR+100*MINOR+MICRO.
   </para>
   <example>
    <title>cairo_version()</title>
    <programlisting role="php">
<![CDATA[
<?php
  // prints e.g. 10202 for cairo 1.2.2
  echo cairo_version();
?>
]]>
   </programlisting>
   </example>
   <para>
    See also <function>cairo_version_string</function>.
   </para>
  </description>
  <code>
    RETURN_LONG(cairo_version());
  </code>
  <test>
   <code>echo is_numeric(cairo_version()) ? "OK" : "ERROR";</code>
  </test>
 </function>

 <function name="cairo_version_string">
  <proto>string cairo_version_string(void)</proto>
  <summary>Return cairo library version string</summary>
  <description>
   <para>
    Returns the Cairo library version as a dot delimited three part version string.
   </para>
   <example>
    <title>cairo_version_string</title>
    <programlisting role="php">
<![CDATA[
<?php
  // prints e.g. 1.2.2
  echo cairo_version_string();
?>
]]>     
    </programlisting>
   </example>
   <para>
    See also <function>cairo_version</function>.
   </para>
  </description>
  <code>
    RETURN_STRING((char*)cairo_version_string(), 1);
  </code>
  <test>
   <code>echo preg_match('|\d\.\d\.\d|', cairo_version_string()) ? "OK" : "ERROR";</code>
  </test>
 </function>

 <function name="cairo_save">
  <proto>void cairo_save(resource cairo_context cr)</proto>
  <summary>Save current drawing context settings</summary>
  <description>
   ...
  </description>
  <code>
    cairo_save(cr);
  </code>
 </function>

 <function name="cairo_restore">
  <proto>void cairo_restore(resource cairo_context cr)</proto>
  <summary>Restore drawing context settings peviously saved</summary>
  <description>
   ...
  </description>
  <code>
    cairo_restore(cr);
  </code>
 </function>

 <function name="cairo_status">
  <proto>int cairo_status(resource cairo_context cr)</proto>
  <summary>Get current drawing context status</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_status(cr));
  </code>
 </function>

 <function name="cairo_pattern_status">
  <proto>int cairo_pattern_status(resource cairo_pattern pattern)</proto>
  <summary>Get current fill pattern status</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_pattern_status(pattern));
  </code>
 </function>


 <function name="cairo_status_to_string">
  <proto>string cairo_status_to_string(int status)</proto>
  <summary>Get descriptive message for status code</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_STRING((char*)cairo_status_to_string(status), 1);
  </code>
 </function>

<!-- TODO look up resource holding target surface
 <function name="cairo_get_target">
  <proto>resource cairo_surface cairo_get_target(resource cairo_context cr)</proto>
  <summary>...</summary>
  <description>
   ...
  </description>
  <code>
    cairo_surface_t * target = cairo_get_target(cr);
    // TODO look up resource holding this surface
  </code>
 </function>

 <function name="cairo_get_group_target">
  <proto>resource cairo_surface cairo_get_group_target(resource cairo_context cr)</proto>
  <summary>...</summary>
  <description>
   ...
  </description>
  <code>
    return_res = cairo_get_group_target(cr);
  </code>
 </function>

 <function name="cairo_surface_reference">
  <proto>resource cairo_surface cairo_surface_reference(resource cairo_surface surface)</proto>
  <summary>...</summary>
  <description>
   ...
  </description>
  <code>
    return_res = cairo_surface_reference(surface);
  </code>
 </function>

 <function name="cairo_reference">
  <proto>resource cairo_context cairo_reference(resource cairo_context cr)</proto>
  <summary>...</summary>
  <description>
   ...
  </description>
  <code>
    return_res = cairo_reference(cr);
  </code>
 </function>

 <function name="cairo_pattern_reference">
  <proto>resource cairo_pattern cairo_pattern_reference(resource cairo_pattern pattern)</proto>
  <summary>...</summary>
  <description>
   ...
  </description>
  <code>
    return_res = cairo_pattern_reference(pattern);
  </code>
 </function>
/TODO -->

 <function name="cairo_push_group">
  <proto>void cairo_push_group(resource cairo_context cr)</proto>
  <summary>Redirect drawing to an intermediate surface</summary>
  <description>
   ...
  </description>
  <code>
    cairo_push_group(cr);
  </code>
 </function>

 <function name="cairo_pop_group">
  <proto>resource cairo_pattern cairo_pop_group(resource cairo_context cr)</proto>
  <summary>Create pattern from intermediate surface</summary>
  <description>
   ...
  </description>
  <code>
    return_res = cairo_pop_group(cr);
  </code>
 </function>

 <function name="cairo_pop_group_to_source">
  <proto>void cairo_pop_group_to_source(resource cairo_context cr)</proto>
  <summary>Set source fill pattern from intermediate surface</summary>
  <description>
   ...
  </description>
  <code>
    cairo_pop_group_to_source(cr);
  </code>
 </function>

 <function name="cairo_rotate">
  <proto>void cairo_rotate(resource cairo_context cr, float angle)</proto>
  <summary>Rotate current drawing context</summary>
  <description>
   ...
  </description>
  <code>
    cairo_rotate(cr, angle);
  </code>
 </function>

 <function name="cairo_translate">
  <proto> void cairo_translate(resource cairo_context cr, float tx, float ty)</proto>
  <summary>Move origin of current drawing context</summary>
  <description>
   ...
  </description>
  <code>
    cairo_translate(cr, tx, ty);
  </code>
 </function>

 <function name="cairo_curve_to">
  <proto>void cairo_curve_to(resource cairo_context cr, float x1, float y1, float x2, float y2, float x3, float y3)</proto>
  <summary>Draw cubic spline given absolute control points</summary>
  <description>
   ...
  </description>
  <code>
    cairo_curve_to(cr, x1, y1, x2, y2, x3, y3);
  </code>
 </function>

 <function name="cairo_rel_curve_to">
  <proto>void cairo_rel_curve_to(resource cairo_context cr, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)</proto>
  <summary>Draw cubic spline with control points relative to the current position</summary>
  <description>
   ...
  </description>
  <code>
    cairo_rel_curve_to(cr, dx1, dy1, dx2, dy2, dx3, dy3);
  </code>
 </function>

 <function name="cairo_close_path">
  <proto>void cairo_close_path(resource cairo_context cr)</proto>
  <summary>Close current drawing path with a line to the path starting point</summary>
  <description>
   ...
  </description>
  <code>
    cairo_close_path(cr);
  </code>
 </function>

 <function name="cairo_set_antialias">
  <proto>void cairo_set_antialias(resource cairo_context cr, int antialias)</proto>
  <summary>Set antialias mode</summary>
  <description>
   ...
  </description>
  <code>
    cairo_set_antialias(cr, antialias);
  </code>
 </function>

 <function name="cairo_get_antialias">
  <proto>int cairo_get_antialias(resource cairo_context cr)</proto>
  <summary>Get current antialias mode</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_get_antialias(cr));
  </code>
 </function>

 <function name="cairo_set_fill_rule">
  <proto>void cairo_set_fill_rule(resource cairo_context cr, int fill_rule)</proto>
  <summary>Set fill rule</summary>
  <description>
   ...
  </description>
  <code>
    cairo_set_fill_rule(cr, fill_rule);
  </code>
 </function>

 <function name="cairo_get_fill_rule">
  <proto>int cairo_get_fill_rule(resource cairo_context cr)</proto>
  <summary>Get current fill rule</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_get_fill_rule(cr));
  </code>
 </function>

 <function name="cairo_set_line_cap">
  <proto>void cairo_set_line_cap(resource cairo_context cr, int line_cap)</proto>
  <summary>Set line caps mode</summary>
  <description>
   ...
  </description>
  <code>
    cairo_set_line_cap(cr, line_cap);
  </code>
 </function>

 <function name="cairo_get_line_cap">
  <proto>int cairo_get_line_cap(resource cairo_context cr)</proto>
  <summary>Get current line caps mode</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_get_line_cap(cr));
  </code>
 </function>

 <function name="cairo_set_line_join">
  <proto>void cairo_set_line_join(resource cairo_context cr, int line_join)</proto>
  <summary>Set line join style</summary>
  <description>
   ...
  </description>
  <code>
    cairo_set_line_join(cr, line_join);
  </code>
 </function>

 <function name="cairo_get_line_join">
  <proto>int cairo_get_line_join(resource cairo_context cr)</proto>
  <summary>Get current line join style</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_get_line_join(cr));
  </code>
 </function>

 <function name="cairo_set_tolerance">
  <proto>void cairo_set_tolerance(resource cairo_context cr, float tolerance)</proto>
  <summary>Set curve conversion tolerance</summary>
  <description>
   ...
  </description>
  <code>
    cairo_set_tolerance(cr, tolerance);
  </code>
 </function>

 <function name="cairo_get_tolerance">
  <proto>float cairo_get_tolerance(resource cairo_context cr)</proto>
  <summary>Get current curve conversion tolerance</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_DOUBLE(cairo_get_tolerance(cr));
  </code>
 </function>

 <function name="cairo_set_miter_limit">
  <proto>void cairo_set_miter_limit(resource cairo_context cr, float miter_limit)</proto>
  <summary>Set miter limit</summary>
  <description>
   ...
  </description>
  <code>
    cairo_set_miter_limit(cr, miter_limit);
  </code>
 </function>

 <function name="cairo_get_miter_limit">
  <proto>float cairo_get_miter_limit(resource cairo_context cr)</proto>
  <summary>Get current miter limit</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_DOUBLE(cairo_get_miter_limit(cr));
  </code>
 </function>

 <function name="cairo_set_operator">
  <proto>void cairo_set_operator(resource cairo_context cr, int operator)</proto>
  <summary>Set compositing operator</summary>
  <description>
   ...
  </description>
  <code>
    cairo_set_operator(cr, operator);
  </code>
 </function>

 <function name="cairo_get_operator">
  <proto>int cairo_get_operator(resource cairo_context cr)</proto>
  <summary>Get current compositing operator</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_get_operator(cr));
  </code>
 </function>

 <function name="cairo_paint">
  <proto>void cairo_paint(resource cairo_context cr)</proto>
  <summary>Paint current source fill pattern in complete clip region</summary>
  <description>
   ...
  </description>
  <code>
   cairo_paint(cr);
  </code>
 </function>

 <function name="cairo_paint_with_alpha">
  <proto>void cairo_paint_with_alpha(resource cairo_context cr, float alpha)</proto>
  <summary>Paint current source fill pattern transparently in complete clip region</summary>
  <description>
   ...
  </description>
  <code>
   cairo_paint_with_alpha(cr, alpha);
  </code>
 </function>

 <function name="cairo_surface_flush">
  <proto>void cairo_surface_flush(resource cairo_surface surface)</proto>
  <summary>Flush pending operations to device</summary>
  <description>
   ...
  </description>
  <code>
   cairo_surface_flush(surface);
  </code>
 </function>

 <function name="cairo_clip">
  <proto>void cairo_clip(resource cairo_context cr)</proto>
  <summary>Create new clip region from current clip region and path</summary>
  <description>
   ...
  </description>
  <code>
    cairo_clip(cr);
  </code>
 </function>

 <function name="cairo_clip_preserve">
  <proto>void cairo_clip_preserve(resource cairo_context cr)</proto>
  <summary>Create new clip region from current clip region and path, keep path for further operations</summary>
  <description>
   ...
  </description>
  <code>
    cairo_clip_preserve(cr);
  </code>
 </function>

 <function name="cairo_reset_clip">
  <proto>void cairo_reset_clip(resource cairo_context cr)</proto>
  <summary>Reset clipping region</summary>
  <description>
   ...
  </description>
  <code>
    cairo_reset_clip(cr);
  </code>
 </function>

 <function name="cairo_image_surface_get_height">
  <proto>int cairo_image_surface_get_height(resource cairo_surface surface)</proto>
  <summary>Get height of a bitmap image surface in pixels</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_image_surface_get_height(surface));
  </code>
 </function>

 <function name="cairo_image_surface_get_width">
  <proto>int cairo_image_surface_get_width(resource cairo_surface surface)</proto>
  <summary>Get width of a bitmap image surface in pixels</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_image_surface_get_width(surface));
  </code>
 </function>

 <function name="cairo_surface_status">
  <proto>void cairo_surface_status(resource cairo_surface surface)</proto>
  <summary>Get current surface status</summary>
  <description>
   ...
  </description>
  <code>
    cairo_surface_status(surface);
  </code>
 </function>

 <function name="cairo_in_fill">
  <proto>bool cairo_in_fill(resource cairo_context cr, float x, float y)</proto>
  <summary>Check whether the given point would be modified by the next fill operation</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_BOOL(cairo_in_fill(cr, x, y));
  </code>
 </function>

 <function name="cairo_in_stroke">
  <proto>bool cairo_in_stroke(resource cairo_context cr, float x, float y)</proto>
  <summary>Check whether the given point would be modified by the next stroke operation</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_BOOL(cairo_in_stroke(cr, x, y));
  </code>
 </function>

 <function name="cairo_new_path">
  <proto>void cairo_new_path(resource cairo_context cr)</proto>
  <summary>Start fresh drawing path, purge any previous path information</summary>
  <description>
   ...
  </description>
  <code>
    cairo_new_path(cr);
  </code>
 </function>

 <function name="cairo_new_sub_path">
  <proto>void cairo_new_sub_path(resource cairo_context cr)</proto>
  <summary>Start a new sub path</summary>
  <description>
   ...
  </description>
  <code>
    cairo_new_sub_path(cr);
  </code>
 </function>

 <function name="cairo_image_surface_get_type">
  <proto>int cairo_image_surface_get_type(resource cairo_surface surface)</proto>
  <summary>Get type of bitmap image surface</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_image_surface_get_type(surface));
  </code>
 </function>

 <function name="cairo_image_surface_get_format">
  <proto>int cairo_image_surface_get_format(resource cairo_surface surface)</proto>
  <summary>Get format of bitmap image surface</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_image_surface_get_format(surface));
  </code>
 </function>

 <function name="cairo_pattern_set_extend">
  <proto>void cairo_pattern_set_extend(resource cairo_pattern pattern, int extend)</proto>
  <summary>Set fill pattern extend mode</summary>
  <description>
   ...
  </description>
  <code>
    cairo_pattern_set_extend(pattern, extend);
  </code>
 </function>

 <function name="cairo_copy_page">
  <proto>void cairo_copy_page(resource cairo_context cr)</proto>
  <summary>Finish current page and start a new one preserving the surface contents</summary>
  <description>
   ...
  </description>
  <code>
    cairo_copy_page(cr);
  </code>
 </function>

 <function name="cairo_show_page">
  <proto>void cairo_show_page(resource cairo_context cr)</proto>
  <summary>Finish current page and start a new empty one</summary>
  <description>
   ...
  </description>
  <code>
    cairo_show_page(cr);
  </code>
 </function>

 <function name="cairo_copy_path">
  <proto>resource cairo_path cairo_copy_path(resource cairo_context cr)</proto>
  <summary>Get current path from drawing context</summary>
  <description>
   ...
  </description>
  <code>
    return_res = cairo_copy_path(cr);
  </code>
 </function>

 <function name="cairo_copy_path_flat">
  <proto>resource cairo_path cairo_copy_path_flat(resource cairo_context cr)</proto>
  <summary>Get current path from drawing context, convert all curves to straight line segments</summary>
  <description>
   ...
  </description>
  <code>
    return_res = cairo_copy_path_flat(cr);
  </code>
 </function>

 <function name="cairo_append_path">
  <proto>void cairo_append_path(resource cairo_context cr, resource cairo_path path)</proto>
  <summary>Append a given path to the current drawing context path</summary>
  <description>
   ...
  </description>
  <code>
    cairo_append_path(cr, path);
  </code>
 </function>

 <function name="cairo_get_source">
  <proto>resource cairo_pattern cairo_get_source(resource cairo_context cr)</proto>
  <summary>Get current source fill pattern from drawing context</summary>
  <description>
   ...
  </description>
  <code>
    return_res = cairo_get_source(cr);
  </code>
 </function>

 <function name="cairo_mask">
  <proto>void cairo_mask(resource cairo_context cr, resource cairo_pattern pattern)</proto>
  <summary>Paint current source fill pattern using alpha channel mask pattern</summary>
  <description>
   ...
  </description>
  <code>
    cairo_mask(cr, pattern);
  </code>
 </function>

 <function name="cairo_mask_surface">
  <proto>void cairo_mask_surface(resource cairo_context cr, resource cairo_surface  surface, float surface_x, float surface_y)</proto>
  <summary>Paint current source fill pattern using a surface as alpha channel mask</summary>
  <description>
   ...
  </description>
  <code>
    cairo_mask_surface(cr, surface, surface_x, surface_y);
  </code>
 </function>
 


 <function name="cairo_pattern_get_extend">
  <proto>int cairo_pattern_get_extend(resource cairo_pattern pattern)</proto>
  <summary>Get fill pattern extend mode</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_pattern_get_extend(pattern));
  </code>
 </function>

 <function name="cairo_pattern_get_filter">
  <proto>int cairo_pattern_get_filter(resource cairo_pattern pattern)</proto>
  <summary>Get fill pattern filter setting</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_pattern_get_filter(pattern));
  </code>
 </function>

 <function name="cairo_pattern_get_pattern_type">
  <proto>int cairo_pattern_get_pattern_tpye(resource cairo_pattern pattern)</proto>
  <summary>Get fill pattern type</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_pattern_get_pattern_type(pattern));
  </code>
 </function>

 <function name="cairo_surface_mark_dirty">
  <proto>void cairo_surface_mark_dirty(resource cairo_surface surface)</proto>
  <summary>Mark surface as dirty due to non-cairo drawing operations</summary>
  <description>
   ...
  </description>
  <code>
    cairo_surface_mark_dirty(surface);
  </code>
 </function>

 <function name="cairo_surface_mark_dirty_rectangle">
  <proto>void cairo_surface_make_dirty_rectangle(resource cairo_surface surface, int x, int y, int width, int height)</proto>
  <summary>Mark part of the surface as dirty due to non-cairo drawing operations</summary>
  <description>
   ...
  </description>
  <code>
    cairo_surface_mark_dirty_rectangle(surface, x, y, width, height);
  </code>
 </function>

 <function name="cairo_surface_set_fallback_resolution">
  <proto>void cairo_surface_set_fallback_resolution(resource cairo_surface surface, float x_pixels_per_inch, float y_pixels_per_inch)</proto>
  <summary>Set resolution for fallback operations on images not supported by the current surface</summary>
  <description>
   ...
  </description>
  <code>
    cairo_surface_set_fallback_resolution(surface, x_pixels_per_inch, y_pixels_per_inch);
  </code>
 </function>

 <function name="cairo_surface_set_device_offset">
  <proto>void cairo_surface_set_device_offset(resource cairo_surface surface, float x_offset, float y_offset)</proto>
  <summary>Set device drawing offset</summary>
  <description>
   ...
  </description>
  <code>
    cairo_surface_set_devide_offset(surface, x_offset, y_offset);
  </code>
 </function>

 <function name="cairo_set_source_surface">
  <proto>void cairo_set_source_surface(resource cairo_context cr, resource cairo_surface  surface, float x, float y)</proto>
  <summary>Create drawing context source fill pattern from surface</summary>
  <description>
   ...
  </description>
  <code>
    cairo_set_source_surface(cr, surface, x, y);
  </code>
 </function>

 <function name="cairo_svg_surface_create" if="CAIRO_HAS_SVG_SURFACE">
  <proto>resource cairo_surface cairo_svg_surface_create(string path, float width_in_points, float height_in_points)</proto>
  <summary>Create a Scalabel Vector Graphics surface</summary>
  <description>
   ...
  </description>
  <code>
    cairo_status_t status;
    php_stream *stream = php_stream_open_wrapper((char *)path, "wb", ENFORCE_SAFE_MODE | REPORT_ERRORS, NULL);

    if (!stream) {
      RETURN_FALSE;
    }
 
    return_res = cairo_svg_surface_create_for_stream(_cairo_write_stream, stream, width_in_points, height_in_points);
    status = cairo_surface_set_user_data(return_res, (cairo_user_data_key_t *)cairo_svg_surface_create, stream, _cairo_close_stream);
  </code>
 </function>

 <function name="cairo_svg_surface_restrict_to_version" if="CAIRO_HAS_SVG_SURFACE">
  <proto>void cairo_svg_surface_restrict_to_version(resource cairo_surface surface, int version)</proto>
  <summary>Set SVG version to produce output for</summary>
  <description>
   ...
  </description>
  <code>
   cairo_svg_surface_restrict_to_version(surface, version);
  </code>
 </function>

 <function name="cairo_svg_version_to_string" if="CAIRO_HAS_SVG_SURFACE">
  <proto>string cairo_svg_version_to_string(int version)</proto>
  <summary>Get descriptive SVG version info</summary>
  <description>
   ...
  </description>
  <code>
   RETURN_STRING((char *)cairo_svg_version_to_string(version), 1);
  </code>
 </function>

 <function name="cairo_text_path">
  <proto>void cairo_text_path(resource cairo_context cr, string text)</proto>
  <summary>Create drawing path from text</summary>
  <description>
   ...
  </description>
  <code>
   cairo_text_path(cr, text);
  </code>
 </function>

 <resource name="cairo_font_face" payload="cairo_font_face_t" alloc="no">
  <description>
   A simple font face resource.
  </description>
  <destruct>
   cairo_font_face_destroy(resource);   
  </destruct>
 </resource>

 <resource name="cairo_scaled_font" payload="cairo_scaled_font_t" alloc="no">
  <description>
   A scaled cairo font.
  </description>
  <destruct>
   cairo_scaled_font_destroy(resource);   
  </destruct>
 </resource>

 <function name="cairo_get_font_face">
  <proto>resource cairo_font_face cairo_get_font_face(resource cairo_context cr)</proto>
  <summary>Get current font face</summary>
  <description>
   ...
  </description>
  <code>
    if (!(return_res = cairo_get_font_face(cr))) {
      RETURN_FALSE;
    }
  </code>
 </function>

 <function name="cairo_font_face_destroy">
  <proto>void cairo_font_destroy(resource cairo_font_face font_face)</proto>
  <summary>Destry font face resource</summary>
  <description>
   ...
  </description>
  <code>
    FREE_RESOURCE(font_face_res);
  </code>
 </function>


 <function name="cairo_font_face_get_type">
  <proto>int cairo_font_face_get_type(resource cairo_font_face font_face)</proto>
  <summary>Get font face type</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_font_face_get_type(font_face));
  </code>
 </function>

 <function name="cairo_font_face_status">
  <proto>int cairo_font_face_status(resource cairo_font_face font_face)</proto>
  <summary>Get font face status</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_font_face_status(font_face));
  </code>
 </function>

 <function name="cairo_set_font_face">
  <proto>void cairo_set_font_face(resource cairo_context cr, resource cairo_font_face font_face)</proto>
  <summary>Set new font face for drawing context</summary>
  <description>
   ...
  </description>
  <code>
    cairo_set_font_face(cr, font_face);
  </code>
 </function>

 <resource name="cairo_font_options" payload="cairo_font_options_t" alloc="no">
  <description>
   A collection of font options.
  </description>
  <destruct>
   cairo_font_options_destroy(resource);   
  </destruct>
 </resource>

 <function name="cairo_font_options_create">
  <proto>resource cairo_font_options cairo_font_options_create(void)</proto>
  <summary>Create font options resource</summary>
  <description>
   ...
  </description>
  <code>
    return_res = cairo_font_options_create();
  </code>
 </function>

 <function name="cairo_font_options_copy">
  <proto>resource cairo_font_options cairo_font_options_copy(resource cairo_font_options font_options)</proto>
  <summary>Create a copy of an existing font options resource</summary>
  <description>
   ...
  </description>
  <code>
    return_res = cairo_font_options_copy(font_options);
  </code>
 </function>

 <function name="cairo_font_options_destroy">
  <proto>void cairo_font_options_destroy(resource cairo_font_options font_options)</proto>
  <summary>Destroy a font options resource</summary>
  <description>
   ...
  </description>
  <code>
    FREE_RESOURCE(font_options_res);
  </code>
 </function>

 <function name="cairo_set_font_options">
  <proto>void cairo_set_font_options(resource cairo_context cr, resource cairo_font_options font_options)</proto>
  <summary>Set font options for current drawing font</summary>
  <description>
   ...
  </description>
  <code>
    cairo_set_font_options(cr, font_options);
  </code>
 </function>

 <function name="cairo_font_options_set_antialias">
  <proto>void cairo_font_options_set_antialias(resource cairo_font_options font_options, int antialias)</proto>
  <summary>Set antialias font option</summary>
  <description>
   ...
  </description>
  <code>
    cairo_font_options_set_antialias(font_options, antialias);
  </code>
 </function>

 <function name="cairo_font_options_set_hint_metrics">
  <proto>void cairo_font_options_set_hint_metrics(resource cairo_font_options font_options, int hint_metrics)</proto>
  <summary>Set hint metrics font option</summary>
  <description>
   ...
  </description>
  <code>
    cairo_font_options_set_hint_metrics(font_options, hint_metrics);
  </code>
 </function>

 <function name="cairo_font_options_set_hint_style">
  <proto>void cairo_font_options_set_hint_style(resource cairo_font_options font_options, int hint_style)</proto>
  <summary>Set hint style font option</summary>
  <description>
   ...
  </description>
  <code>
    cairo_font_options_set_hint_style(font_options, hint_style);
  </code>
 </function>

 <function name="cairo_font_options_set_subpixel_order">
  <proto>void cairo_font_options_set_subpixel_order(resource cairo_font_options font_options, int subpixel_order)</proto>
  <summary>Set subpixel order font option</summary>
  <description>
   ...
  </description>
  <code>
    cairo_font_options_set_subpixel_order(font_options, subpixel_order);
  </code>
 </function>

 <function name="cairo_font_options_get_antialias">
  <proto>int cairo_font_options_get_antialias(resource cairo_font_options font_options)</proto>
  <summary>Get antialias setting from font option</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_font_options_get_antialias(font_options));
  </code>
 </function>

 <function name="cairo_font_options_get_hint_metrics">
  <proto>int cairo_font_options_get_hint_metrics(resource cairo_font_options font_options)</proto>
  <summary>Get hint metrics setting from font option</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_font_options_get_hint_metrics(font_options));
  </code>
 </function>

 <function name="cairo_font_options_get_hint_style">
  <proto>int cairo_font_options_get_hint_style(resource cairo_font_options font_options)</proto>
  <summary>Get hint style setting from font option</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_font_options_get_hint_style(font_options));
  </code>
 </function>

 <function name="cairo_font_options_get_subpixel_order">
  <proto>int cairo_font_options_get_subpixel_order(resource cairo_font_options font_options)</proto>
  <summary>Get subpixel order setting from fong option</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_font_options_get_subpixel_order(font_options));
  </code>
 </function>

 <function name="cairo_font_options_equal">
  <proto>bool cairo_font_options_equal(resource cairo_font_options options, resource cairo_font_options other)</proto>
  <summary>Compare two font options</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_BOOL(cairo_font_options_equal(options, other));
  </code>
 </function>

 <function name="cairo_font_options_merge">
  <proto>void cairo_font_options_merge(resource cairo_font_options options, resource cairo_font_options other)</proto>
  <summary>Merge font options</summary>
  <description>
   ...
  </description>
  <code>
    cairo_font_options_merge(options, other);
  </code>
 </function>

 <function name="cairo_font_options_status">
  <proto>int cairo_font_options_status(resource cairo_font_options options)</proto>
  <summary>Get font options status</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_font_options_status(options));
  </code>
 </function>

 <function name="cairo_get_font_options">
  <proto>void cairo_get_font_options(resource cairo_context cr, resource cairo_font_options options)</proto>
  <summary>Get current font options from drawing context</summary>
  <description>
   ...
  </description>
  <code>
    cairo_get_font_options(cr, options);
  </code>
 </function>

 <function name="cairo_surface_get_font_options">
  <proto>void cairo_surface_get_font_options(resource cairo_surface surface, resource cairo_font_options options)</proto>
  <summary>Get current font options from surface</summary>
  <description>
   ...
  </description>
  <code>
    cairo_surface_get_font_options(surface, options);
  </code>
 </function>

 <function name="cairo_path_to_array">
  <proto>array cairo_path_to_array(resource cairo_path path)</proto>
  <summary>Extract drawing operations from path</summary>
  <description>
   ...
  </description>
  <code>
<![CDATA[
   int i, j, num_points;
   zval *data, *points, *point;  
   cairo_path_data_t *path_data = path->data;

   for (i = 0; i < path->num_data; i++) {
     MAKE_STD_ZVAL(data);
     array_init(data);

     MAKE_STD_ZVAL(points);
     array_init(points);

     num_points = path_data->header.length - 1;

     add_assoc_long(data, "type",   path_data->header.type);
     add_assoc_long(data, "length", num_points);

     for (j = 0; j < num_points; j++) {
       i++;

       path_data++;

       MAKE_STD_ZVAL(point);
       array_init(point);
       add_index_double(point, 0, path_data->point.x);
       add_index_double(point, 1, path_data->point.y);
       
       add_index_zval(points, j, point);
     }

     add_assoc_zval(data, "points", points);

     add_next_index_zval(return_value, data);
   
     path_data++;
   }
]]>
  </code>
 </function>

 <resource name="cairo_matrix" payload="cairo_matrix_t" alloc="yes">
  <description>
   A 2D trasformation matrix used in various transformation operations.
  </description>
 </resource>

 <function name="cairo_marix_destroy">
  <proto>void cairo_matrix_destroy(resource cairo_context cr)</proto>
  <summary>Destroy transformation matrix</summary>
  <description>
   ...
  </description>
  <code>
    FREE_RESOURCE(cr_res);
  </code>
 </function>

 <function name="cairo_get_matrix">
  <proto>resource cairo_matrix cairo_get_matrix(resource cairo_context cr)</proto>
  <summary>Get current transformation matrix from drawing context</summary>
  <description>
   ...
  </description>
  <code>
    cairo_get_matrix(cr, return_res);
  </code>
 </function>

 <function name="cairo_set_matrix">
  <proto>void cairo_set_matrix(resource cairo_context cr, resource cairo_matrix matrix)</proto>
  <summary>Set transformation matrix for drawing context</summary>
  <description>
   ...
  </description>
  <code>
    cairo_set_matrix(cr, matrix);
  </code>
 </function>

 <function name="cairo_identity_matrix">
  <proto>void cairo_identity_matrix(resource cairo_context cr)</proto>
  <summary>Reset drawing context transformation matrix</summary>
  <description>
   ...
  </description>
  <code>
    cairo_identity_matrix(cr);
  </code>
 </function>

 <function name="cairo_matrix_invert">
  <proto>void cairo_matrix_invert(resource cairo_matrix matrix)</proto>
  <summary>Invert the given matrix</summary>
  <description>
   ...
  </description>
  <code>
    cairo_matrix_invert(matrix);
  </code>
 </function>

 <function name="cairo_matrix_create">
  <proto>resource cairo_matrix cairo_matrix_create(float xx, float yx, float xy, float yy, float x0, float y0)</proto>
  <summary>Create a new matrix from parameters</summary>
  <description>
   ...
  </description>
  <code>
    cairo_matrix_init(return_res, xx, yx, xy, yy, x0, y0);
  </code>
 </function>

 <function name="cairo_matrix_create_identity">
  <proto>resource cairo_matrix cairo_matrix_create_identity(void)</proto>
  <summary>Create a new identity matrix</summary>
  <description>
   ...
  </description>
  <code>
    cairo_matrix_init_identity(return_res);
  </code>
 </function>

 <function name="cairo_matrix_create_rotate">
  <proto>resource cairo_matrix cairo_matrix_create_rotate(float radians)</proto>
  <summary>Create a new rotation matrix</summary>
  <description>
   ...
  </description>
  <code>
    cairo_matrix_init_rotate(return_res, radians);
  </code>
 </function>

 <function name="cairo_matrix_create_translate">
  <proto>resource cairo_matrix cairo_matrix_create_translate(float dx, float dy)</proto>
  <summary>Create a new translation matrix</summary>
  <description>
   ...
  </description>
  <code>
    cairo_matrix_init_translate(return_res, dx, dy);
  </code>
 </function>

 <function name="cairo_matrix_create_scale">
  <proto>resource cairo_matrix cairo_matrix_create_scale(float sx, float sy)</proto>
  <summary>Create a new scaling matrix</summary>
  <description>
   ...
  </description>
  <code>
    cairo_matrix_init_scale(return_res, sx, sy);
  </code>
 </function>

 <function name="cairo_matrix_multiply">
  <proto>resource cairo_matrix_multiply(resource cairo_matrix m1, resource cairo_matrix m2)</proto>
  <summary>Multiply two transformation matrixes</summary>
  <description>
   ...
  </description>
  <code>
    cairo_matrix_multiply(return_res, m1, m2);
  </code>
 </function>

 <function name="cairo_matrix_rotate">
  <proto>void cairo_matrix_rotate(resource cairo_matrix matrix, float radians)</proto>
  <summary>Rote a matrix</summary>
  <description>
   ...
  </description>
  <code>
    cairo_matrix_rotate(matrix, radians);
  </code>
 </function>

 <function name="cairo_matrix_translate">
  <proto>void cairo_matrix_translate(resource cairo_matrix matrix, float dx, float dy)</proto>
  <summary>Translate a matrix</summary>
  <description>
   ...
  </description>
  <code>
    cairo_matrix_translate(matrix, dx, dy);
  </code>
 </function>

 <function name="cairo_matrix_scale">
  <proto>void cairo_matrix_scale(resource cairo_matrix matrix, float sx, float sy)</proto>
  <summary>Scale a matrix</summary>
  <description>
   ...
  </description>
  <code>
    cairo_matrix_scale(matrix, sx, sy);
  </code>
 </function>

 <function name="cairo_transform">
  <proto>void cairo_transform(resource cairo_context cr, resource cairo_matrix matrix)</proto>
  <summary>Add transformation to a drawing context</summary>
  <description>
   ...
  </description>
  <code>
    cairo_transform(cr, matrix);
  </code>
 </function>
 

 <function name="cairo_pattern_get_matrix">
  <proto>resource cairo_matrix cairo_pattern_get_matrix(resource cairo_pattern pattern)</proto>
  <summary>Get fill pattern transformation matrix</summary>
  <description>
   ...
  </description>
  <code>
    cairo_pattern_get_matrix(pattern, return_res);
  </code>
 </function>

 <function name="cairo_pattern_set_matrix">
  <proto>void cairo_pattern_set_matrix(resource cairo_pattern pattern, resource cairo_matrix matrix)</proto>
  <summary>Set fill pattern transformation matrix</summary>
  <description>
   ...
  </description>
  <code>
    cairo_pattern_set_matrix(pattern, matrix);
  </code>
 </function>

 <function name="cairo_get_font_matrix">
  <proto>resource cairo_matrix cairo_get_font_matrix(resource cairo_context cr)</proto>
  <summary>Get current font transformation from drawing context</summary>
  <description>
   ...
  </description>
  <code>
    cairo_get_font_matrix(cr, return_res);
  </code>
 </function>

 <function name="cairo_set_font_matrix">
  <proto>void cairo_set_matrix(resource cairo_context cr, resource cairo_matrix matrix)</proto>
  <summary>Set font transformation matrix for drawing context</summary>
  <description>
   ...
  </description>
  <code>
    cairo_set_font_matrix(cr, matrix);
  </code>
 </function>




 <function name="cairo_scaled_font_destroy">
  <proto>void cairo_scaled_font_destroy(resource cairo_scaled_font scaled_font)</proto>
  <summary>Destroy scaled font resource</summary>
  <description>
   ...
  </description>
  <code>
    FREE_RESOURCE(scaled_font_res);
  </code>
 </function>

 <function name="cairo_scaled_font_create">
  <proto>resource cairo_scaled_font cairo_scaled_font_create(resource cairo_font_face font_face,  resource cairo_matrix font_matrix,  resource cairo_matrix ctm,  resource cairo_font_options options)</proto>
  <summary>Create a scaled font resource</summary>
  <description>
   ...
  </description>
  <code>
    return_res = cairo_scaled_font_create(font_face,  font_matrix,  ctm, options);
  </code>
 </function>


 <function name="cairo_scaled_font_get_type">
  <proto>int cairo_scaled_font_get_type(resource cairo_scaled_font scaled_font)</proto>
  <summary>Get scaled font type</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_scaled_font_get_type(scaled_font));
  </code>
 </function>

 <function name="cairo_scaled_font_status">
  <proto>int cairo_scaled_font_status(resource cairo_scaled_font scaled_font)</proto>
  <summary>Get scaled font status</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_scaled_font_status(scaled_font));
  </code>
 </function>

 <function name="cairo_scaled_font_get_font_matrix">
  <proto>resource cairo_matrix cairo_scaled_font_get_font_matrix(resource cairo_scaled_font scaled_font)</proto>
  <summary>Get scaled font user space transformation matrix</summary>
  <description>
   ...
  </description>
  <code>
    cairo_scaled_font_get_font_matrix(scaled_font, return_res);
  </code>
 </function>

 <function name="cairo_scaled_font_get_ctm">
  <proto>resource cairo_matrix cairo_scaled_font_get_font_ctm(resource cairo_scaled_font scaled_font)</proto>
  <summary>Get scaled font device space transformation matrix</summary>
  <description>
   ...
  </description>
  <code>
    cairo_scaled_font_get_ctm(scaled_font, return_res);
  </code>
 </function>

 <function name="cairo_scaled_font_get_font_options">
  <proto>resource cairo_font_options cairo_scaled_font_get_font_options(resource cairo_scaled_font scaled_font)</proto>
  <summary>Get scaled fonts font options</summary>
  <description>
   ...
  </description>
  <code>
    cairo_scaled_font_get_font_options(scaled_font, return_res);
  </code>
 </function>

 <function name="cairo_scaled_font_get_font_face">
  <proto>resource cairo_font_face cairo_scaled_font_get_font_face(resource cairo_scaled_font scaled_font)</proto>
  <summary>Get scaled fonts face</summary>
  <description>
   ...
  </description>
  <code>
    return_res = cairo_scaled_font_get_font_face(scaled_font);
  </code>
 </function>

 <function name="cairo_set_scaled_font">
  <proto>void cairo_set_scaled_font(resource cairo_context cr, resource cairo_scaled_font scaled_font)</proto>
  <summary>Set scaled font for drawing context</summary>
  <description>
   ...
  </description>
  <code>
    cairo_set_scaled_font(cr, scaled_font);
  </code>
 </function>

 <function name="cairo_surface_get_scaled_font_options">
  <proto>resource cairo_font_options cairo_surface_get_scaled_font_options(resource cairo_surface surface)</proto>
  <summary>Get scaled font options form surface</summary>
  <description>
   ...
  </description>
  <code>
    cairo_surface_get_scaled_font_options(surface, return_res);
  </code>
 </function>

 <function name="cairo_svg_get_versions">
  <proto>array cairo_svg_get_versions(void)</proto>
  <summary>Get available SVG versions</summary>
  <description>
   ...
  </description>
  <code>
<![CDATA[
    const cairo_svg_version_t *versions;
    int num_versions, i;

    cairo_svg_get_versions(&versions, &num_versions);

    for (i = 0; i < num_versions; i++) {
      add_next_index_long(return_value, versions[i]);
    }
]]>
  </code>
 </function>


 <function name="cairo_get_current_point">
  <proto>array cairo_get_current_point(resource cairo_context cr)</proto>
  <summary>Get current drawing position from drawing context</summary>
  <description>
   ...
  </description>
  <code>
<![CDATA[
    double x, y;

    cairo_get_current_point(cr, &x, &y);

    add_next_index_double(return_value, x);
    add_next_index_double(return_value, y);
]]>
  </code>
 </function>

 <function name="cairo_matrix_transform_point">
  <proto>array cairo_matrix_transform_point(resource cairo_matrix matrix, float x, float y)</proto>
  <summary>Transform absolute point using transformation matrix</summary>
  <description>
   ...
  </description>
  <code>
<![CDATA[
    cairo_matrix_transform_point(matrix, &x, &y);

    add_next_index_double(return_value, x);
    add_next_index_double(return_value, y);
]]>
  </code>
 </function>

 <function name="cairo_matrix_transform_distance">
  <proto>array cairo_matrix_transform_distance(resource cairo_matrix matrix, float dx, float dy)</proto>
  <summary>Transform relative distance using transformation matrix</summary>
  <description>
   ...
  </description>
  <code>
<![CDATA[
    cairo_matrix_transform_distance(matrix, &dx, &dy);

    add_next_index_double(return_value, dx);
    add_next_index_double(return_value, dy);
]]>
  </code>
 </function>

 <function name="cairo_device_to_user">
  <proto>array cairo_device_to_user(resource cairo_context cr, float x, float y)</proto>
  <summary>Convert device space coordinates to user space</summary>
  <description>
   ...
  </description>
  <code>
<![CDATA[
    cairo_device_to_user(cr, &x, &y);

    add_next_index_double(return_value, x);
    add_next_index_double(return_value, y);
]]>
  </code>
 </function>

 <function name="cairo_device_to_user_distance">
  <proto>array cairo_device_to_user_distance(resource cairo_context cr, float dx, float dy)</proto>
  <summary>Convert device space relative position to user space</summary>
  <description>
   ...
  </description>
  <code>
<![CDATA[
    cairo_device_to_user_distance(cr, &dx, &dy);

    add_next_index_double(return_value, dx);
    add_next_index_double(return_value, dy);
]]>
  </code>
 </function>

 <function name="cairo_user_to_device">
  <proto>array cairo_user_to_device(resource cairo_context cr, float x, float y)</proto>
  <summary>Convert user space coordinates to device space</summary>
  <description>
   ...
  </description>
  <code>
<![CDATA[
    cairo_user_to_device(cr, &x, &y);

    add_next_index_double(return_value, x);
    add_next_index_double(return_value, y);
]]>
  </code>
 </function>

 <function name="cairo_user_to_device_distance">
  <proto>array cairo_user_to_device_distance(resource cairo_context cr, float dx, float dy)</proto>
  <summary>Convert user space relative position to device space</summary>
  <description>
   ...
  </description>
  <code>
<![CDATA[
    cairo_user_to_device_distance(cr, &dx, &dy);

    add_next_index_double(return_value, dx);
    add_next_index_double(return_value, dy);
]]>
  </code>
 </function>

 <function name="cairo_surface_get_device_offset">
  <proto>array cairo_surface_get_device_offset(resource cairo_surface surface)</proto>
  <summary>Get surface to device translation offset</summary>
  <description>
   ...
  </description>
  <code>
<![CDATA[
    double x_offset, y_offset;

    cairo_surface_get_device_offset(surface, &x_offset, &y_offset);

    add_next_index_double(return_value, x_offset);
    add_next_index_double(return_value, y_offset);
]]>
  </code>
 </function>

 <function name="cairo_fill_extents">
  <proto>array cairo_fill_extends(resource cairo_context cr)</proto>
  <summary>Get current fill extends from drawing context</summary>
  <description>
   ...
  </description>
  <code>
<![CDATA[
    double x1, y1, x2, y2;

    cairo_fill_extends(cr, &x1, &y1, &x2, &y2);
    add_next_index_double(return_value, x1);
    add_next_index_double(return_value, y1);
    add_next_index_double(return_value, x2);
    add_next_index_double(return_value, y2);
]]>
  </code>
 </function>

 <function name="cairo_stroke_extents">
  <proto>array cairo_stroke_extends(resource cairo_context cr)</proto>
  <summary>Get current stroke extends from drawing context</summary>
  <description>
   ...
  </description>
  <code>
<![CDATA[
    double x1, y1, x2, y2;

    cairo_stroke_extends(cr, &x1, &y1, &x2, &y2);
    add_next_index_double(return_value, x1);
    add_next_index_double(return_value, y1);
    add_next_index_double(return_value, x2);
    add_next_index_double(return_value, y2);
]]>
  </code>
 </function>

 <function name="cairo_text_extends">
  <proto>array cairo_text_extends(resource cairo_context cr, string text)</proto>
  <summary>Get text extends for given string</summary>
  <description>
   ...
  </description>
  <code>
<![CDATA[
    cairo_text_extents_t ext;

    cairo_text_extents(cr, text, &ext);

    add_assoc_double(return_value, "x_bearing", ext.x_bearing);
    add_assoc_double(return_value, "y_bearing", ext.y_bearing);
    add_assoc_double(return_value, "width",     ext.width);
    add_assoc_double(return_value, "height",    ext.height);
    add_assoc_double(return_value, "x_advance", ext.x_advance);
    add_assoc_double(return_value, "y_advance", ext.y_advance);

]]>
  </code>
 </function>

 <function name="cairo_surface_get_content">
  <proto>int cairo_surface_get_content(resource cairo_surface surface)</proto>
  <summary>Get surface content type</summary>
  <description>
   ...
  </description>
  <code>
    RETURN_LONG(cairo_surface_get_content(surface));
  </code>
 </function>

 <function name="cairo_pattern_set_filter">
  <proto>void cairo_pattern_set_filter(resource cairo_pattern pattern, int filter)</proto>
  <summary>Set fill pattern filter type</summary>
  <description>
   ...
  </description>
  <code>
    cairo_pattern_set_filter(pattern, filter);
  </code>
 </function>

 <function name="cairo_push_group_with_content">
  <proto>void cairo_push_group_with_content(resource cairo_context cr, int content)</proto>
  <summary>Redirect drawing to an intermediate surface of given content type</summary>
  <description>
   ...
  </description>
  <code>
   cairo_push_group_with_content(cr, content);
  </code>
 </function>

 <function name="cairo_surface_create_similar">
  <proto>resource cairo_surface cairo_surface_create_similar(resource cairo_surface surface, int content, int width, int height)</proto>
  <summary>Create a new surface similar to an existing one</summary>
  <description>
   ...
  </description>
  <code>
    return_res = cairo_surface_create_similar(surface, content, width, height);
  </code>
 </function>

 <function name="cairo_set_dash">
  <proto>void cairo_set_dash(resource cairo_context cr, array dashes, float offset)</proto>
  <summary>Set line dash style</summary>
  <description>
   ...
  </description>
  <code>
<![CDATA[
    int num_dashes, n;
    double *dash_values, *pd;
    zval **ppzval;
 
    num_dashes = zend_hash_num_elements(Z_ARRVAL_P(dashes));
    dash_values = (double *)calloc(sizeof(double), num_dashes);    

    zend_hash_internal_pointer_reset(Z_ARRVAL_P(dashes));
    
    pd = dash_values;
    for (n = 0; n < num_dashes; n++) {
      zend_hash_get_current_data(Z_ARRVAL_P(dashes), (void**)&ppzval);
      *pd++ = Z_DVAL_PP(ppzval);
    }

    cairo_set_dash(cr, dash_values, num_dashes, offset);
]]>
  </code>
 </function>


 <function name="cairo_font_extents">
  <proto>array cairo_font_extents(resource cairo_context cr)</proto>
  <summary>Get font extets for current font</summary>
  <description>
   ...
  </description>
  <code>
<![CDATA[
    cairo_font_extents_t ext;

    cairo_font_extents(cr, &ext);

    add_assoc_double(return_value, "ascent", ext.ascent);
    add_assoc_double(return_value, "descent", ext.descent);
    add_assoc_double(return_value, "height", ext.height);
    add_assoc_double(return_value, "max_x_advance", ext.max_x_advance);
    add_assoc_double(return_value, "max_y_advance", ext.max_y_advance);
]]>
  </code>
 </function>

 <function name="cairo_scaled_font_extents">
  <proto>array cairo_scaled_font_extents(resource cairo_scaled_font font)</proto>
  <summary>Get font extents for given scaled font</summary>
  <description>
   ...
  </description>
  <code>
<![CDATA[
    cairo_font_extents_t ext;

    cairo_scaled_font_extents(font, &ext);

    add_assoc_double(return_value, "ascent", ext.ascent);
    add_assoc_double(return_value, "descent", ext.descent);
    add_assoc_double(return_value, "height", ext.height);
    add_assoc_double(return_value, "max_x_advance", ext.max_x_advance);
    add_assoc_double(return_value, "max_y_advance", ext.max_y_advance);
]]>
  </code>
 </function>

 <function name="cairo_scaled_font_text_extends">
  <proto>array cairo_scaled_font_text_extends(resource cairo_scaled_font font, string text)</proto>
  <summary>Get text extends for a string using the given scaled font</summary>
  <description>
   ...
  </description>
  <code>
<![CDATA[
    cairo_text_extents_t ext;

    cairo_scaled_font_text_extents(font, text, &ext);

    add_assoc_double(return_value, "x_bearing", ext.x_bearing);
    add_assoc_double(return_value, "y_bearing", ext.y_bearing);
    add_assoc_double(return_value, "width",     ext.width);
    add_assoc_double(return_value, "height",    ext.height);
    add_assoc_double(return_value, "x_advance", ext.x_advance);
    add_assoc_double(return_value, "y_advance", ext.y_advance);

]]>
  </code>
 </function>


</extension>
